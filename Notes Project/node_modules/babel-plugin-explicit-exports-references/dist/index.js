(()=>{"use strict";var e={n:t=>{var n=t&&t.__esModule?()=>t.default:()=>t;return e.d(n,{a:n}),n},d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};((e,t,n)=>{n.r(t),n.d(t,{default:()=>p});const r=JSON.parse('{"u2":"babel-plugin-explicit-exports-references"}'),i=require("debug");var o=n.n(i);const a=require("@babel/template");var s=n.n(a);const d=o()(`${r.u2}:index`);let l;function c(e,t,n){var r;const i=(null!==(r=e.isIdentifier)&&void 0!==r&&r.call(e)?e:e.from).node.name,o=e.to||i,a=l.getBinding(i),c=[...(null==a?void 0:a.referencePaths)||[],...(null==a?void 0:a.constantViolations)||[]],p=(null==c?void 0:c.length)||0,f=d.extend(`mode-${t}:updating`);f(p?`potentially updating ${p} references to ${t} export "${i}"`+(o!=i?` (exported as "${o}")`:""):"no references to update"),null==c||c.forEach(((e,r)=>{const i=`ref-${o}-${(r+1).toString()}`;e.find((e=>e.isExportSpecifier()||e.isExportNamespaceSpecifier()||e.isExportDefaultSpecifier()))?f(`[${i}] reference skipped: part of an export specifier`):e.find((e=>e.isTSType()))?f(`[${i}] reference skipped: TypeScript type reference`):e.isIdentifier()?(f(`[${i}] transforming type "identifier"`),e.replaceWith(s().expression.ast`module.exports.${"default"==t?t:o}`)):n&&e.isAssignmentExpression()?(f(`[${i}] transforming type "assignment expression"`),e.get("left").replaceWith(s().expression.ast`module.exports.${"default"==t?t:o}`)):f(`[${i}] reference skipped: unsupported type "${e.type}"`)}))}function p(){return{name:"explicit-exports-references",visitor:{Program(e){l=e.scope},ExportDefaultDeclaration(e,t){const n=e.get("declaration"),r=t.opts.transformAssignExpr,i=d.extend("mode-default");if(d("encountered default export declaration"),n.isFunctionDeclaration()||n.isClassDeclaration()){var o;const e=n.get("id");null!=e&&null!==(o=e.node)&&void 0!==o&&o.name?c(e,"default",r):i("default declaration is anonymous, ignored")}else i("default declaration not function or class, ignored")},ExportNamedDeclaration(e,t){const n=e.get("declaration"),r=e.get("specifiers"),i=t.opts.transformAssignExpr,o=d.extend("mode-named");n.node||r.length?(d("encountered named export node"),o("processing declaration"),n.node&&(n.isFunctionDeclaration()||n.isClassDeclaration()?c(n.get("id"),"named",i):n.isVariableDeclaration()?n.get("declarations").forEach((e=>{const t=e.get("id");t.isIdentifier()?c(t,"named",i):t.isObjectPattern()&&t.get("properties").forEach((e=>{if(e.isObjectProperty()){const t=e.get("value");t.isIdentifier()&&c(t,"named",i)}else if(e.isRestElement()){const t=e.get("argument");t.isIdentifier()&&c(t,"named",i)}}))})):o("named declaration is not a function, class, or variable declaration; ignored")),r.length&&o(`processing ${r.length} specifiers`),r.forEach((e=>{if(e.isExportSpecifier()){const t=e.get("local"),n=e.get("exported");if(o(`encountered specifier "${t} as ${n}"`),n.isIdentifier()){const e=n.node.name;c({from:t,to:e},"default"==e?"default":"named",i)}else o("ignored export specifier because module string names are not supported")}else o(`ignored export specifier type "${e.type}"`)}))):o("ignored empty named export declaration")}}}}})(0,t,e),module.exports=t})();